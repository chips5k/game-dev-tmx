<!doctype html>
<html>
    <head>
    </head>
    <body>
        
        <script>

            function Edge(start, end) {
                this.start = start;
                this.end = end;
            }

            //create a new edge that is e translated by v units 
            Edge.translate = function(e, v) {
                let c = e.clone();
                c.start.add(v);
                c.end.add(v);
                return c;
            }

            //translate self by v units
            Edge.prototype.translate = function(v) {
                this.start.add(v);
                this.end.add(v);
                return this;
            }   

            //create a new edge that is the project of e1 onto e2
            Edge.project = function(e1, e2) {

                //obtain a vector representing the edge to project onto
                //E.g this is edge 2 orientation/length  but from origin 0, 0
                let axis = e2.difference();


                //Next project the start and end of edge 1 onto this axis
                let e1StartProjection = Vector2d.project(e1.start, axis);
                let e1EndProjection = Vector2d.project(e1.end, axis);


                //Next project edge 2 onto the axis we calculated from it 
                let e2StartProjection =  Vector2d.project(e2.start, axis);
                

                //Currently we have edge 1 projected against the axis of edge 2, the axis if you recall,
                //is drawn from origin, and not the true location of edge 2. thus we need to remove the projection of edge 2 (start) onto its axis projection, from projections A and B in order to reduce the two projections to their true unit lengths FROM the start of edge 2.
                // once the projection of edge 2 has been subtracted, we can then ADD the start of edge 2 to both, which provide us with the true coordinates.
                //The above is quite possibly the most fucked up comment i have written....i promise i'll come back and give it some love...
                let edge3 = new Edge(e1StartProjection.subtract(e2StartProjection).add(e2.start), e1EndProjection.subtract(e2StartProjection).add(e2.start));

                return edge3;
            
            };  

            
            //project self onto edge e
            Edge.prototype.project = function(e) {
                this.start.project(e.end);
                this.end.project(e.end);
                return this;
            }
            

            Edge.prototype.difference = function() {
                return Vector2d.subtract(this.end, this.start);
            }

            Edge.difference = function(e) {
                return Vector2d.subtract(e.end, e.start);
            }



            Edge.prototype.clone = function() {
                return new Edge(this.start.clone(), this.end.clone());
            }

            Edge.clone = function(e) {
                return new Edge(e.start.clone(), e.end.clone());
            }

            Edge.prototype.normal = function() {
                //extract a normal/unit vector representing the orientation of this edge
                return Vector2d.subtract(this.end, this.start).normalize();
            }
            //Expand this edge by x units in either direction
            Edge.prototype.expand = function(x) {

                let normal = this.normal();
                let expansion = Vector2d.multiply(normal, x);
                this.start.subtract(expansion);
                this.end.add(expansion);

                return this;

            }

            //Create a version of e expanded by x in either direction
            Edge.expand = function(e, x) {
                let normal = e.normal();
                let expansion = Vector2d.multiply(normal, x);
                let c = e.clone();
                c.start.subtract(expansion);
                c.end.add(expansion);
                return c;
            }


            document.addEventListener('DOMContentLoaded', function(e) {
                // let game = new Game();
                // game.run(); 


                let canvas = document.createElement('canvas');
                canvas.width = 400;
                canvas.height = 600;

                document.body.appendChild(canvas);
                
                let ctx = canvas.getContext('2d');
                
                
                let edgeA = new Edge(new Vector2d(100, 100), new Vector2d(200, 50));
                let edgeB = new Edge(new Vector2d(0, 0), new Vector2d(300, 180));

                let edgeC = Edge.project(edgeA, edgeB);

                    
                let edgeRenderQueue = [ 
                    {
                        color: 'blue',
                        edge: edgeA
                    }, 
                    {
                        color: 'red',
                        edge: edgeB
                    }, 
                    {
                        color: 'pink',
                        edge: edgeC
                    },
                ]; 
                
                for(let i in edgeRenderQueue) {
                    let item = edgeRenderQueue[i];
                    ctx.beginPath();
                    ctx.moveTo(item.edge.start.x, item.edge.start.y);
                    ctx.lineTo(item.edge.end.x, item.edge.end.y);
                    ctx.closePath();
                    ctx.strokeStyle = item.color;
                    ctx.stroke();
                }

            });


            
            function Game() {
                let self = this;

                self.currentHeight = 400;
                self.currentWidth = 600;

                self.canvas = document.createElement('canvas');
                self.canvas.width = self.currentWidth;
                self.canvas.height = self.currentHeight;

                document.body.appendChild(self.canvas);
                
                self.ctx = self.canvas.getContext('2d');
                
                self.startTimestamp = self.getTimestamp();
                self.currentTickTimestamp = self.startTimestamp;
                self.lastTickTimestamp = self.startTimestamp;
                self.numTicks = 0;
                self.tickTimestep = 16;//milliseconds
                self.keyMap = {};

                self.spriteSheet = null;                
                
                self.viewport = {
                    x: 0, 
                    y: 0,
                    width: 600,
                    height: 400
                };

                self.imageMap = [
                    { x: 0, y: 63 },
                    { x: 63, y: 0 },
                    { x: 0, y: 0 },
                    { x: 127, y: 0},
                    { x: 127, y: 63 }
                ];

                self.player = new Player(new Vector2d(264,264));
                
               

                self.tileRigidBodies = {
                    // '1': new RigidBody([
                    //     new ConstrainedPath(new Vector2d(0, 0), new Vector2d(0, 64)),
                    //     new ConstrainedPath(new Vector2d(0, 64), new Vector2d(64, 64)),
                    //     new ConstrainedPath(new Vector2d(64, 64), new Vector2d(0, 0))
                    // ]),
                    // '2': new RigidBody([
                    //     new ConstrainedPath(new Vector2d(0, 0), new Vector2d(0, 64)),
                    //     new ConstrainedPath(new Vector2d(0, 64), new Vector2d(64, 64)),
                    //     new ConstrainedPath(new Vector2d(64, 64), new Vector2d(0, 0))
                    // ]),
                    // '4': new RigidBody([
                    //     new ConstrainedPath(new Vector2d(0, 0), new Vector2d(0, 64)),
                    //     new ConstrainedPath(new Vector2d(0, 64), new Vector2d(64, 64)),
                    //     new ConstrainedPath(new Vector2d(64, 64), new Vector2d(0, 0))
                    // ])
                };

                self.scene = [
                    [
                        [
                            { z: 0, image: 1, collidable: true},
                            { z: 0, image: 2, collidable: true},
                            { z: 0, image: 1, collidable: true},
                            { z: 0, image: 1, collidable: true},
                            { z: 0, image: 1, collidable: true},
                            { z: 0, image: 2, collidable: true},
                            { z: 0, image: 1, collidable: true},
                            { z: 0, image: 2, collidable: true},
                            { z: 0, image: 3, collidable: true},
                        ],
                        [
                            { z: 0, image: 0, collidable: false},
                            { z: 0, image: 0, collidable: false},
                            { z: 0, image: 0, collidable: false},
                            { z: 0, image: 0, collidable: false},
                            { z: 0, image: 0, collidable: false},
                            { z: 0, image: 0, collidable: false},
                            { z: 0, image: 0, collidable: false},
                            { z: 0, image: 0, collidable: false},
                            { z: 0, image: 0, collidable: false},  
                        ],
                        [
                            { z: 0, image: 0, collidable: false},
                            { z: 0, image: 0, collidable: false},
                            { z: 0, image: 0, collidable: false},
                            { z: 0, image: 0, collidable: false},
                            { z: 0, image: 0, collidable: false},
                            { z: 0, image: 0, collidable: false},
                            { z: 0, image: 0, collidable: false},
                            { z: 0, image: 0, collidable: false},
                            { z: 0, image: 0, collidable: false},  
                        ]
                    ],
                    [
                        [
                            { z: 0, image: null, collidable: false},
                            { z: 0, image: null, collidable: false},
                            { z: 0, image: null, collidable: false},
                            { z: 0, image: null, collidable: false},
                            { z: 0, image: null, collidable: false},
                            { z: 0, image: null, collidable: false},
                            { z: 0, image: null, collidable: false},
                            { z: 0, image: null, collidable: false},
                            { z: 0, image: null, collidable: false},
                        ], 
                        [
                            { z: 0, image: 0, collidable: false},
                            { z: 0, image: 0, collidable: false},
                            { z: 0, image: 0, collidable: false},
                            { z: 0, image: 0, collidable: false},
                            { z: 0, image: 0, collidable: false},
                            { z: 0, image: 0, collidable: false},
                            { z: 0, image: 0, collidable: false},
                            { z: 0, image: 0, collidable: false},
                            { z: 0, image: 4, collidable: true},  
                        ],
                        [
                            { z: 0, image: 0, collidable: false},
                            { z: 0, image: 0, collidable: false},
                            { z: 0, image: 0, collidable: false},
                            { z: 0, image: 0, collidable: false},
                            { z: 0, image: 0, collidable: false},
                            { z: 0, image: 0, collidable: false},
                            { z: 0, image: 0, collidable: false},
                            { z: 0, image: 0, collidable: false},
                            { z: 0, image: 4, collidable: true},  
                        ],
                    ]
                    
                ];

            }

            Game.prototype.loadAssets = function() {
                let self = this;

                return new Promise(function(resolve, reject) {
                    
                    self.spriteSheet = new Image();
                    self.spriteSheet.src = 'tilesheet.png';
                    
                    self.spriteSheet.addEventListener('load', function() {
                        resolve();
                    });
                });

            }

            Game.prototype.run = function() {
                let self = this;
                self.registerListeners();

                

                
                self.loadAssets().then(function() {
                    
                    self.tick();
                })
            }

            Game.prototype.getTimestamp = function() {
                let self = this;

                return window.performance.now();
            }

            Game.prototype.tick = function() {
                let self = this;

                self.numTicks++;
                self.lastTickTimestamp = self.currentTickTimestamp;
                self.currentTickTimestamp = self.getTimestamp();

                window.requestAnimationFrame(self.tick.bind(self));

                //calculated time elapsed since last tick
                self.accumulatedSinceLastTick = self.currentTickTimestamp - self.lastTickTimestamp;

                while(self.accumulatedSinceLastTick >= 16) {
                    self.accumulatedSinceLastTick--;
                    self.processInput();
                    self.processPhysics();
                    
                }

                //Render scene
                self.clearCanvas();
                //Need to interpolate physics state based on any remaining time to smooth things out
                self.renderScene();
                self.renderUi();
                
            }

            Game.prototype.processInput = function() {
                let self = this;

                let edge = self.player.boundingBox.path.edges[0];
                let direction = Vector2d.subtract(edge.path[1], edge.path[0]).normalize();
               

                if(self.keyMap['s']) {
                    self.player.translate(new Vector2d(0, 1));
                    
                    self.player.boundingBox.path.correctEdges();

                }

                if(self.keyMap['w']) {
                    self.player.translate(new Vector2d(0, -1));
                    
                    self.player.boundingBox.path.correctEdges();

                }

                if(self.keyMap['a']) {
                    self.player.translate(new Vector2d(-1, 0));
                    
                    self.player.boundingBox.path.correctEdges();

                }

                if(self.keyMap['d']) {
                    self.player.translate(new Vector2d(1, 0));
                    
                    self.player.boundingBox.path.correctEdges();

                }
            }


            Game.prototype.findTileCoordinates = function(pX, pY) {
                let self = this;
                let points = {
                    'topLeft': {pX: pX, pY: pY},
                    'bottomRight': {pX: pX + 64, pY: pY + 64},
                    'topRight': {pX: pX + 64, pY: pY},
                    'bottomLeft': {pX: pX, pY: pY + 64} 
                }
                
                let keys = Object.keys(points);
                for(let i in keys) {
                    let key = keys[i];
                    let tX = points[key].pX / 64;
                    let tY = points[key].pY / 64;
                    
                    
                    let iTx = parseInt(tX);
                    let iTy = parseInt(tY);
                    
                    
                    if(key === 'topRight' || key === 'bottomRight') {
                        if(tX - iTx <= 0) {
                            iTx--;
                        }
                    } else {
                        if(tX - iTx < 0) {
                            iTx--;
                        }
                    }

                    if(key === 'bottomLeft' || key === 'bottomRight') {
                        if(tY - iTy <= 0) {
                            iTy--;
                        }
                    } else {
                        if(tY - iTy < 0) {
                            iTy--;
                        }
                    }

                    points[key] = { tX: iTx, tY: iTy};
                }

                return points;
            }

            Game.prototype.findPixelPosition = function(tX, tY) {
                return {x: 0, y: 0};
            }

            Game.prototype.processPhysics = function() {
                let self = this;


                // let tileCoordinates = self.findTileCoordinates(self.player.topLeft().x, self.player.topLeft().y);
                
                // let keys = Object.keys(tileCoordinates);
                // for(let i in keys) {
                //     let tileCoord = tileCoordinates[keys[i]];
                //     //Check if a tile exists at the specified coordinate
                //     for(let x in self.scene) {
                //         let layer = self.scene[x];
                //         if(layer[tileCoord.tY] && layer[tileCoord.tY][tileCoord.tX] && layer[tileCoord.tY][tileCoord.tX].collidable) {
                            
                //             let tile = layer[tileCoord.tY][tileCoord.tX];
                //             let rigidBody = self.tileRigidBodies[tile.image];
                //             // self.player.topLeft().y += 1;
                //             //self.player.topLeft().x -= 1;
                //             //.console.log(self.player.topLeft().vectorA);
                //             //self.player.rigidBody.enforceConstraints();
                           
                            
                //         }
                //     }


                // }
                
            }

            Game.prototype.renderScene = function() {
                let self = this;
                
                for(let l in self.scene) {
                    let layer = self.scene[l];
                    for(let tY in layer) {
                        let row = layer[tY];
                        for(let tX in row) {
                            let tile = row[tX];
                            
                            if(tile.image !== null) {
                                if(tY * 64 + 64 >= self.viewport.y && tX * 64 + 64 >= self.viewport.x) {
                                    self.ctx.drawImage(self.spriteSheet, self.imageMap[tile.image].x, self.imageMap[tile.image].y, 64, 64, tX * 64 - self.viewport.x, tY * 64 - self.viewport.y, 64, 64);
                                }
                            }
                        }
                    }
                }

                
                for(var i in self.player.boundingBox.path.edges) {
                    
                    let edge = self.player.boundingBox.path.edges[i];  
                    
                    self.ctx.strokeStyle = 'red';
                    self.ctx.beginPath();
                    self.ctx.moveTo(edge.path[0].x, edge.path[0].y);
                    self.ctx.lineTo(edge.path[1].x, edge.path[1].y);
                    self.ctx.closePath();
                    self.ctx.stroke();

                    if(i == 0) {
                        self.ctx.fillStyle = 'yellow';
                        self.ctx.fillRect(edge.path[0].x - 3, edge.path[0].y -3, 6, 6);
                        self.ctx.fillStyle = 'orange';
                        self.ctx.fillRect(edge.path[1].x - 3, edge.path[1].y - 3, 6, 6);
                    }

                }

                // self.ctx.fillRect(self.player.topLeft().x - self.viewport.x, self.player.topLeft().y - self.viewport.y, 64, 64);
            
            }

            Game.prototype.clearCanvas = function() {
                let self = this;
                self.ctx.clearRect(0,0, 600, 400);
            }

            Game.prototype.renderUi = function() {
                let self = this;

                self.ctx.fillStyle = "black";
                self.ctx.font = "30px Arial";
                let fps = self.numTicks / (self.currentTickTimestamp - self.startTimestamp) * 1000;
                self.ctx.fillText("FPS: " + fps.toFixed(0), 10, 50);
                 self.ctx.fillStyle = "white";
                self.ctx.fillText("FPS: " + fps.toFixed(0), 9, 49);

            }

            Game.prototype.registerListeners = function() {
                let self = this;
                
                window.addEventListener('keydown', function(e) {
                    self.keyMap[e.key] = true;
                });

                window.addEventListener('keyup', function(e) {
                    delete self.keyMap[e.key];
                });
            }

            function Player(position) {

                this.boundingBox = new BoundingBox(position, 32, 32);

            }

            Player.prototype.translate = function(vector) {
                this.boundingBox.path.points[0].add(vector);

            }

            
            function BoundingBox(position, width, height) {
                this.path = new Path([
                    new Vector2d(position.x, position.y),
                    new Vector2d(position.x + width, position.y),
                    new Vector2d(position.x + width, position.y + height),
                    new Vector2d(position.x, position.y + height)
                ], [
                    [ 0, 2]
                ]);
            }
            

            function Path(points, constraints) {
                this.points = points;
                this.edges = [];
                this.constraints = [];
                
                for(let i in constraints) {
                    let constraint = constraints[i];
                    this.constraints.push({
                        path: [this.points[constraint[0]], this.points[constraint[1]]],
                        length: Vector2d.subtract(this.points[constraint[1]], this.points[constraint[0]]).magnitude()
                    })
                }

                var currentEdge = [];
                for(let i in this.points) {
                    
                    if(currentEdge.length < 2) {
                        currentEdge.push(this.points[i]);
                        if(currentEdge.length === 2) {
                            this.edges.push({
                                path: currentEdge.slice(),
                                length: Vector2d.subtract(currentEdge[1], currentEdge[0]).magnitude()
                            });
                            currentEdge[0] = currentEdge[1];
                            currentEdge.length = 1;
                        }
                    }
                }

                currentEdge.push(this.points[0]);
                //Close out the path with the final edge
                this.edges.push({
                    path: currentEdge.slice(),
                    length: Vector2d.subtract(currentEdge[1], currentEdge[0]).magnitude()
                });

            }

            Path.prototype.moveTo = function(position) {
                this.points[0].x = position.x;
                this.points[0].y = position.y;
                this.correctEdges();
            }
            
            Path.prototype.correctEdges = function() {
                
                for(var x = 0; x < 3; x++) {
                    for(let i in this.edges) {
                        let edge = this.edges[i];
                        //Calculate current length
                        
                        let v1v2 = Vector2d.subtract(edge.path[1], edge.path[0]);
                        let v1v2Length = v1v2.magnitude();

                        v1v2.normalize();
                        
                        let diff = v1v2Length - edge.length;
                        
                        edge.path[0].add(Vector2d.multiply(v1v2, diff/2));
                        edge.path[1].subtract(Vector2d.multiply(v1v2, diff/2));

                    }
                
                    //Apply constraints
                    for(let i in this.constraints) {
                        let constraint = this.constraints[i];
                        
                        let v1v2 = Vector2d.subtract(constraint.path[1], constraint.path[0]);
                        let v1v2Length = v1v2.magnitude();

                        v1v2.normalize();
                        
                        let diff = v1v2Length - constraint.length;
                        
                        constraint.path[0].add(Vector2d.multiply(v1v2, diff/2));
                        constraint.path[1].subtract(Vector2d.multiply(v1v2, diff/2));
                    }
                }
            }           

            function Vector2d(x, y) {
               this.x = x;
               this.y = y;
            }

            Vector2d.prototype.magnitude = function() {
                    return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2));
            }
                
            Vector2d.prototype.invert = function() {
                this.x = -this.x;
                this.y = -this.y;
                return this;
            }
            Vector2d.invert = function(v) {
                return new Vector2d(-v.x, -v.y);
            }

            Vector2d.prototype.clone = function() {
                return new Vector2d(this.x, this.y);
            }
            
            Vector2d.prototype.add = function(v) {
                this.x += v.x;
                this.y += v.y;
                return this;
            };
            
            Vector2d.add = function(v1, v2) {
                return new Vector2d(v1.x + v2.x, v1.y + v2.y);
            };

            Vector2d.prototype.subtract = function(v) {
                this.x -= v.x;
                this.y -= v.y;
                return this;
            };

            Vector2d.subtract = function(v1, v2) {
                return new Vector2d(v1.x - v2.x, v1.y - v2.y);
            };
            
            Vector2d.prototype.normalize = function(v) {
                    this.divide(this.magnitude());
                    return this;
            };

            Vector2d.normalize = function(v) {
                    return Vector2d.divide(v, v.magnitude());
            };

            Vector2d.prototype.divide = function(scalar) {
                this.x /= scalar;
                this.y /= scalar;
                return this;
            };

            Vector2d.divide = function(v, scalar) {
                return new Vector2d(v.x / scalar, v.y / scalar);
            };

            Vector2d.prototype.multiply = function(scalar) {
                this.x *= scalar;
                this.y *= scalar;
                return this;
            };

            Vector2d.multiply = function(v, scalar) {
                return new Vector2d(v.x * scalar, v.y * scalar);
            };
            
            Vector2d.dot = function(v1, v2) {
                return v1.x * v2.x + v1.y * v2.y;
            };
            
            Vector2d.prototype.dot = function(v2) {
                 return this.x * v2.x + this.y * v2.y;
            };

            Vector2d.prototype.rotate = function(radians) {
                var sin = Math.sin(radians);
                var cos = Math.cos(radians);
                this.x = this.x * cos - this.y * sin;
                this.y = this.x * sin + this.y * cos;
                return this;
            }

            Vector2d.rotate = function(v, radians) {
                var sin = Math.sin(radians);
                var cos = Math.cos(radians);
                var x = v.x * cos - v.y * sin;
                var y = v.x * sin + v.y * cos;
                
                return new Vector2d(x, y);
            }   
            
            //Create a new vector that is v1 projected onto v2
            Vector2d.project = function(v1, v2) {

                let v3 = Vector2d.normalize(v2);
                let v1v2Dot = Vector2d.dot(v1, v3);

                v3.multiply(v1v2Dot);
                
                return v3;

            };

            //Project self onto v2
            Vector2d.prototype.project = function(v2) {
                // let v3 = Vector2d.normalize(v2);
                // let v1v2Dot = Vector2d.dot(this, v3);
                // let v2Dot = Vector2d.dot(v2, v2);

                // this.x = v1v2Dot / v2Dot * this.x;
                // this.y = v1v2Dot / v2Dot * this.y;
                // return this;

            }


        </script>
    </body>
</html>